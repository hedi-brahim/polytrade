package com.polymec.model;

import static javax.persistence.GenerationType.IDENTITY;
import static javax.persistence.GenerationType.SEQUENCE;

import java.io.Serializable;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.SequenceGenerator;
import javax.persistence.Column;
import javax.persistence.Version;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.FetchType;
import javax.persistence.OneToOne;
import javax.persistence.OneToMany;
import javax.persistence.ManyToOne;
import javax.persistence.ManyToMany;
import javax.persistence.JoinTable;
import javax.persistence.JoinColumn;
import javax.persistence.CascadeType;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.SqlResultSetMapping;
import javax.persistence.EntityResult;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;

import org.hibernate.annotations.Type;

// @Entity, which means that this is a mapped entity class
@Entity
// @Table annotation defines the table name in the database that this entity is being mapped to.
// You can skip the table and column names if the type
// and attribute names are exactly the same as the table and column names.
@Table(name = "arts")
@NamedQueries({
    @NamedQuery(name="Article.findAll", query="select c from Article c"),
	//@NamedQuery(name="Article.findAllWithDetail",
	//	query="select distinct c from Article c left join fetch c.articleFrns t"),
	// 'fetch' operator will retrieve all article information together with their telephone details and hobbies.
    @NamedQuery(name="Article.findById",
        query="select distinct c from Article c where c.id = :id")
})
public class Article implements Serializable {
    private Long id;
    //private int quantite;
    private String reference;
    private String designation;
	private double puaht;
	private double puvht;
	private Famille famille = new Famille();	
	//private ArticleFrns articleFrns;	
    //private DateTime birthDate;

	
	/*
	@Id. This means itâ€™s the primary key of the object.
	JPA will use it as the unique identifier when managing the article entity instances
	within its session. Additionally, the @GeneratedValue annotation tells JPA how the id
	value was generated. The IDENTITY strategy means that the id was generated by the backend
	during insert.
	*/
    @Id
	// in case of database oracle, these 2 line replace @GeneratedValue(strategy = IDENTITY)
	//@GeneratedValue(strategy=SEQUENCE, generator = "id_Sequence")
	//@SequenceGenerator(name = "id_Sequence", sequenceName = "seq_article")	
    @GeneratedValue(strategy = IDENTITY)
    @Column(name = "Arts_Num")
    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

	/*
	@Version. This instructs JPA that we would like to use an optimistic locking mechanism, using the version attribute as a control.
	Every time JPA updates a record, it compares the version of the entity instance to that	of the record in the database.
	*/
	/*
    @Version
    @Column(name = "VERSION")
    public int getVersion() {
        return this.version;
    }

    public void setVersion(int version) {
        this.version = version;
    }
*/
/*
	@OneToOne(mappedBy = "article")
	public ArticleFrns getArticleFrns() {
		return this.articleFrns;
	}
	public void setArticleFrns(ArticleFrns articleFrns) {
		this.articleFrns = articleFrns;
	}
	*/
/*
	@Column(name = "sr")
    public int getQuantite() {
        return this.quantite;
    }

    public void setQuantite(int quantite) {
        this.quantite = quantite;
    }
*/	
	@Column(name = "Arts_pat")
    public double getPuaht() {
        return round(this.puaht,3);
    }

    public void setPuaht(double puaht) {
        this.puaht = puaht;
    }

	@Column(name = "Arts_pt")
    public double getPuvht() {
        return round(this.puvht,3);
    }

    public void setPuvht(double puvht) {
        this.puvht = puvht;
    }

	public double round(double value, int places) {
		if (places < 0) throw new IllegalArgumentException();

		BigDecimal bd = new BigDecimal(value);
		bd = bd.setScale(places, RoundingMode.HALF_UP);
		return bd.doubleValue();
	}
	
	// @Column annotation, with the column names provided. You can skip the table and column names if the type
	// and attribute names are exactly the same as the table and column names.
    @Column(name = "Arts_ne")
    public String getReference() {
		/*
		String value = "";
		try{
			byte[] ptext = firstName.getBytes("iso-8859-1");
			value = new String(ptext, "windows-1256");
		}catch( UnsupportedEncodingException e){
			System.out.println("Unsupported character set");
		}catch(NullPointerException e)
        {
           //System.out.print("NullPointerException caught");
			return firstName;
        }
		return value;
		*/
		return reference;
    }

    public void setReference(String reference) {

		this.reference = reference;
	/*
		String value = "";
		try{
			byte[] ptext = firstName.getBytes("windows-1256");
			value = new String(ptext, "iso-8859-1");
			this.firstName = value;
		}catch( UnsupportedEncodingException e){
			System.out.println("Unsupported character set");
		}catch(NullPointerException e)
        {
            //System.out.print("NullPointerException caught");
			this.firstName = firstName;
        }
	*/		
    }

    @Column(name = "Arts_le")
    public String getDesignation() {
		/*
		String value = "";
		try{
			byte[] ptext = lastName.getBytes("iso-8859-1");
			value = new String(ptext, "windows-1256");
		}catch( UnsupportedEncodingException e){
			System.out.println("Unsupported character set");
		}catch(NullPointerException e)
        {
            //System.out.print("NullPointerException caught");
			return lastName;
        }
		return value;
		*/
		return designation;
    }

    public void setDesignation(String designation) {

		this.designation = designation;
	/*
		String value = "";
		try{
			byte[] ptext = lastName.getBytes("windows-1256");
			value = new String(ptext, "iso-8859-1");
			this.lastName = value;
		}catch( UnsupportedEncodingException e){
			System.out.println("Unsupported character set");
		}catch(NullPointerException e)
        {
            //System.out.print("NullPointerException caught");
			this.lastName = lastName;
        }
	*/
    }

		/*
	@Temporal, using the TemporalType.DATE
	value. This means we would like to map the data type from the Java date type (java.util.
	Date) to the SQL date type (java.sql.Date). This allows us to access the attribute birthDate
	in the Article object by using java.util.Date as usual in our application.
	*/
    //@Temporal(TemporalType.DATE)
	/*
    @Column(name = "BIRTH_DATE")
	@Type(type="org.jadira.usertype.dateandtime.joda.PersistentDateTime")
    public DateTime getBirthDate() {
        return this.birthDate;
    }

    public void setBirthDate(DateTime birthDate) {
        this.birthDate = birthDate;
    }
*/
	
	@ManyToOne //(fetch=FetchType.LAZY)
	@JoinColumn(name="arts_fle")	
	public Famille getFamille() {
		return this.famille;
	}

	public void setFamille(Famille famille) {
		this.famille = famille;
	}
	
    @Override
    public String toString() {
        return "Article - Id: " + id + ", Reference: " + reference 
            + ", Designation: " + designation //+ ", Quantite: " + articleFrns.getQuantite() 
			+ ", PUAHT: " + puaht + ", PUVHT: " + puvht;
    }
}
