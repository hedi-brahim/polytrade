package com.polymec.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import static javax.persistence.GenerationType.IDENTITY;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToOne;
import javax.persistence.Table;

// @Entity, which means that this is a mapped entity class
@Entity
// @Table annotation defines the table name in the database that this entity is being mapped to.
// You can skip the table and column names if the type
// and attribute names are exactly the same as the table and column names.
@Table(name = "srvs")
@NamedQueries({
    @NamedQuery(name = "Service.findAll", query = "select c from Service c")
    ,
    @NamedQuery(name = "Service.findById",
            query = "select distinct c from Service c where c.id = :id")
})
public class Service implements Serializable {

    private Long id;
    //private int quantite;
    private String reference;
    private String designation;
    private double puvht;
    private double tva;


    /*
	@Id. This means itâ€™s the primary key of the object.
	JPA will use it as the unique identifier when managing the article entity instances
	within its session. Additionally, the @GeneratedValue annotation tells JPA how the id
	value was generated. The IDENTITY strategy means that the id was generated by the backend
	during insert.
     */
    @Id	
    @GeneratedValue(strategy = IDENTITY)
    @Column(name = "Srvs_Num")
    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /*
	@Version. This instructs JPA that we would like to use an optimistic locking mechanism, using the version attribute as a control.
	Every time JPA updates a record, it compares the version of the entity instance to that	of the record in the database.
     */
 /*
    @Version
    @Column(name = "VERSION")
    public int getVersion() {
        return this.version;
    }

    public void setVersion(int version) {
        this.version = version;
    }
     */


    @Column(name = "Srvs_pt")
    public double getPuvht() {
        //return round(this.puvht,3);
        return this.puvht;
    }

    public void setPuvht(double puvht) {
        this.puvht = puvht;
    }

    @Column(name = "Srvs_ta")
    public double getTva() {
        //return round(this.puvht,3);
        return this.tva;
    }

    public void setTva(double tva) {
        this.tva = tva;
    }

    /*
	public double round(double value, int places) {
		if (places < 0) throw new IllegalArgumentException();

		BigDecimal bd = new BigDecimal(value);
		bd = bd.setScale(places, RoundingMode.HALF_UP);
		return bd.doubleValue();
	}
     */
    // @Column annotation, with the column names provided. You can skip the table and column names if the type
    // and attribute names are exactly the same as the table and column names.
    @Column(name = "Srvs_ne")
    public String getReference() {
        return reference;
    }

    public void setReference(String reference) {

        this.reference = reference;

    }

    @Column(name = "Srvs_le")
    public String getDesignation() {

        return designation;
    }

    public void setDesignation(String designation) {

        this.designation = designation;

    }


    @Override
    public String toString() {
        return "Service - Id: " + id + ", Reference: " + reference
                + ", Designation: " + designation + ", PUVHT: " + puvht;
    }
}
